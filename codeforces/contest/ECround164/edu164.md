1. [Problem - A - Codeforces](https://codeforces.com/contest/1954/problem/A)

题目大意:给一个长度为`n`的丝绸,现在可以以`1`为单位给这个丝绸涂成`m`种颜色,现在bob可以选择其中`k`个单位,给其颜色改变,bob希望最后只剩下一种颜色.问是否可以有一种分配方式,使得bob的愿望不成立?

思路:尽可能均分,除了数量最多的那一份,其余所有的都是需要考改变颜色,比较一下即可

``` cpp
void solve()
{
    int n, m, k;    std::cin >> n >> m >> k;
    if (n - (n + m - 1) / m <= k)   std::cout << "NO";
    else std::cout << "YES";
}

```

2. [Problem - B - Codeforces](https://codeforces.com/contest/1954/problem/B)

题目大意:有一个漂亮数组的定义:可以通过一种操作使得最终的数组,所有的元素都相同.操作是:找到`a[i-1]==a[i+1]`的下标`i`,并且将`a[i] = a[i-1]`.现在给一个漂亮数组,允许从数组当中删除一些元素,问最少删除几个元素就可以让数组变成非漂亮数组

思路:注意到要想构造一个非漂亮数组,只需要满足两个不相同的元素被包裹在一起.但是要注意到也可以让特殊的元素成为数组首或者尾

``` cpp
void solve()
{
    int n;  std::cin >> n;
    std::vector<int> a(n + 1);
    for (int i = 1;i <= n;i++)   std::cin >> a[i];
    int mn = n;
    int pre = 0;
    for (int i = 1;i <= n;i++)
        if (a[i] != a[1]) {
            mn = std::min(mn, i - pre - 1);
            pre = i;
        }
    mn = std::min(mn, n + 1 - pre - 1);
    if (mn == n)   std::cout << -1;
    else std::cout << mn;
}
```

3. [Problem - C - Codeforces](https://codeforces.com/contest/1954/problem/C)

题目大意:数学题,给两个大数字,允许交换相同数位上的数字,问如何交换才可以使两个数字的乘积最大?并输出最终的两个数字

思路:数学题,两个数字越接近,乘积越大,证明略(buhui)

``` cpp
void solve()
{
    std::string a, b;   std::cin >> a >> b;
    int f = 1;
    int n = a.size();
    for (int i = 0;i < n;i++)
    {
        if (a[i] == b[i])   continue;
        else if (f) {
            if (a[i] - '0' < b[i] - '0') std::swap(a[i], b[i]);
            f = 0;
        }
        else {
            if (a[i] - '0' > b[i] - '0') std::swap(a[i], b[i]);
        }
    }
    std::cout << a << '\n' << b;
}
```

4. [Problem - D - Codeforces](https://codeforces.com/contest/1954/problem/D)

题目大意:(什么题目描述,开始看半天没有看懂)   有`n`种颜色,每一种颜色的个数有`a[i]`个,现在有$2^n$种颜色集合(就是选择一些颜色出来,组合成一种统计答案的集合),每一个集合都需要遵循以下要求:把每个颜色集合对应的小球分组,每小组最多两个小球,并且颜色不得相同,问该种颜色集合中,最少需要分多少个小组.然后将数量加到答案,求和,并且模998244353

思路:首先可以发现小球数量和颜色种数都不大,可以考虑dp,其次,对于任意一个颜色集合,要计算该集合的分组数,和该集合的sum和mx密切相关,具体为`mx*2与sum`的关系,因此分组数可以直接用`std::max(mx,(sum + 1)/2)`来计算,那么这只是一个集合,对于那么多的集合,该如何统计呢?<br>因此就考虑如何dp,针对上面的分析,可以知道,和mx,sum有关系,因此考虑定义一个`dp[i][j]`,表示此时的最大值为i,并且sum为j时的方案数,那如何保证此时最大值为i呢?可以排序之后按顺序访问,因此可以优化掉第一维,并且类似于背包的思路和写法...

``` cpp
void solve()
{
    int n;  std::cin >> n;
    std::vector<int> a(n + 1);
    i64 sum = 0;
    for (int i = 1;i <= n;i++)   std::cin >> a[i], sum += a[i];
    std::sort(a.begin() + 1, a.end());

    i64 ans = 0;
    std::vector<i64> f(sum + 1, 0);
    f[0] = 1;
    for (int i = 1;i <= n;i++) {
        for (int j = sum;j >= a[i];j--)
        {
            int mn = std::max(a[i], (j + 1) / 2);
            int res = f[j - a[i]] * mn % mod;
            ans = (ans + res) % mod;
            f[j] += f[j - a[i]];
            f[j] %= mod;
        }
    }
    std::cout << ans;
}
```

5. [Problem - E - Codeforces](https://codeforces.com/contest/1954/problem/E)

题目大意:有一些怪物,和他们的初始血量`a[i]`,现在有伤害为k的链式攻击,攻击会串联所有相邻的且活着的怪物,也就是说如果有一些怪物相邻且此时的血量均大于0,则他们都将受到k点伤害.问k从`1--mx`时,分别最少要攻击多少次

思路:发现,从哪个怪物开始攻击不重要,每一段区间的mn会限制后续的链式攻击,但是如果去维护每个区间的mn的话,问题有点麻烦,因此考虑看每个元素对答案的贡献<br>注意到如果一个元素比他相邻的两个元素要小的话,那该元素对答案的贡献一定是被旁边的覆盖掉的,基于这个思路,可以考虑用某个区间的最值来贡献答案,需要注意的是,如果出现了`5 3 5`这类大小大的数据,中间的元素是会被覆盖两次的,因此还要反向贡献一次来抵消.<br>此外,某个元素对答案的贡献可以用分块的思想考虑,因为当k为某一个区间的时候,该元素都需要一定的次数攻击,因此使用一个差分数组来满足区间加即可,具体的分块写法如下

``` cpp
void solve()
{
    int n;  std::cin >> n;
    std::vector<int> a(n + 2, 0);
    int mx = 0;
    for (int i = 1;i <= n;i++)   std::cin >> a[i], mx = std::max(mx, a[i]);

    std::vector<int> ans(mx + 2, 0);
    for (int i = 1;i <= n;i++) {
        int cnt = 0;
        if (a[i] > a[i - 1]) cnt++;
        if (a[i] < a[i + 1]) cnt--;
        int r = mx;
        while (r) {
            int val = (a[i] + r - 1) / r;
            int l = (a[i] + val - 1) / val;
            ans[l] += cnt * val;
            ans[r + 1] -= cnt * val;
            r = l - 1;
        }
    }

    for (int i = 1;i <= mx;i++) ans[i] += ans[i - 1];
    for (int i = 1;i <= mx;i++)   std::cout << ans[i] << " ";
}
```

